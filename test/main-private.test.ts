import { PatParser, IPatternFile, IPatternItem, IVMAL, IChannel } from '../src/main'

const mockFn = jest.fn();

it("has correct initial values", () => {
	const pat:any = new PatParser();
	expect(pat.ofs).toBe(0);
	expect(pat.buf).toEqual(null);
	expect(pat.res).toEqual({
		correctMagicBytes: null,
		numberOfPatterns: null,
		patterns: null,
		version: null
	});
})

it("can read byte", () => {
	const pat:any = new PatParser()

	pat.buf = Buffer.from([10, 20, 30, 40, 50]);
	pat.ofs = 2;

	expect(pat.readByte()).toBe(30);
	expect(pat.ofs).toBe(3)
})

it("can read uint16", () => {
	const pat:any = new PatParser()

	pat.buf = Buffer.from([0x10, 0x20, 0x30, 0x40, 0x50,]);
	pat.ofs = 2;

	expect(pat.readUInt16()).toBe(12352);
	expect(pat.ofs).toBe(4)
})

it("can read uint32", () => {
	const pat:any = new PatParser()

	pat.buf = Buffer.from([0x10, 0x20, 0x30, 0x40, 0x50,0x60,0x70]);
	pat.ofs = 2;

	expect(pat.readUInt32()).toBe(809521248);
	expect(pat.ofs).toBe(6)
})

it("can read magic bytes", () => {
	const pat:any = new PatParser();
	pat.buf = Buffer.from([56, 66, 80, 84])
	pat.verifyMagicBytes();
	expect(pat.res.correctMagicBytes).toBe(true)
})

it("can read utf16 string", () => {
	const pat:any = new PatParser();
	pat.buf = Buffer.from([56, 66, 80, 84, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0,
		0, 3, 0, 1, 0, 1, 0, 0, 0, 39, 0, 80, 1, 89, 0, 237,
		0, 108, 0, 105, 1, 97, 0, 32, 1, 126, 0, 108, 0, 117, 1, 101,
		0, 111, 0, 117, 1, 13, 0, 107, 0, 253, 0, 32, 0, 107, 1, 111,
		1, 72, 0, 32, 0, 250, 0, 112, 1, 27, 0, 108, 0, 32, 1, 15,
		0, 225, 0, 98, 0, 101, 0, 108, 0, 115, 0, 107, 0, 233, 0, 32,
		0, 243, 0, 100, 0, 121, 0, 0, 36, 57, 48
	]);

	pat.ofs = 22;
	expect(pat.readUTF16String()).toBe("Příliš žluťoučký kůň úpěl ďábelské ódy")
})

it("can read UUID", () => {
	const pat:any = new PatParser();
	pat.buf = Buffer.from([56, 66, 80, 84, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 3, 0, 1, 0, 1, 0, 0, 0, 39, 0, 80, 1, 89, 0,
		237, 0, 108, 0, 105, 1, 97, 0, 32, 1, 126, 0, 108, 0, 117, 1, 101, 0, 111, 0, 117, 1, 13, 0, 107, 0, 253, 0, 32, 0, 107, 1,
		111, 1, 72, 0, 32, 0, 250, 0, 112, 1, 27, 0, 108, 0, 32, 1, 15, 0, 225, 0, 98, 0, 101, 0, 108, 0, 115, 0, 107, 0, 233, 0, 32,
		0, 243, 0, 100, 0, 121, 0, 0, 36, 57, 48, 55, 98, 102, 56, 102, 102, 45, 50, 54, 57, 99, 45, 99, 100, 52, 48, 45, 56, 57,
		97, 98, 45, 100, 52, 98, 51, 53, 55, 101, 56, 53, 102, 51, 53, 0, 0, 0, 3, 0, 0, 0, 208, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0
	]);

	pat.ofs = 104;
	expect(pat.readUUID()).toEqual("$907bf8ff-269c-cd40-89ab-d4b357e85f35");
})

it("can read compresion mode", () => {
	const pat:any = new PatParser();
	pat.buf = Buffer.from([5,0, 1, 2, 3]);
	pat.ofs = 1;
	expect(pat.readCompressionMode()).toBe("NONE");	
	expect(pat.ofs).toBe(2);
	pat.ofs = 2;
	expect(pat.readCompressionMode()).toBe("PackBits");

	pat.ofs = 3;
	expect(() => { pat.readCompressionMode() }).toThrow();
})

it("can read color mode", () => {
	const pat:any = new PatParser();
	pat.buf = Buffer.from([0, 0, 0, 0]);
	expect(pat.readColorMode()).toBe("BITMAP")
	pat.ofs = 0;

	pat.buf = Buffer.from([0, 0, 0, 1]);
	expect(pat.readColorMode()).toBe("GRAYSCALE")
	pat.ofs = 0;

	pat.buf = Buffer.from([0, 0, 0, 2]);
	expect(pat.readColorMode()).toBe("INDEXED")
	pat.ofs = 0;

	pat.buf = Buffer.from([0, 0, 0, 3]);
	expect(pat.readColorMode()).toBe("RGB")
	pat.ofs = 0;

	pat.buf = Buffer.from([0, 0, 0, 4]);
	expect(pat.readColorMode()).toBe("CMYK")
	pat.ofs = 0;

	pat.buf = Buffer.from([0, 0, 0, 5]);
	expect(()=>{pat.readColorMode()}).toThrow()
	pat.ofs = 0;

	pat.buf = Buffer.from([0, 0, 0, 6]);
	expect(()=>{pat.readColorMode()}).toThrow()
	pat.ofs = 0;

	pat.buf = Buffer.from([0, 0, 0, 7]);
	expect(pat.readColorMode()).toBe("MULTICHANNEL")
	pat.ofs = 0;

	pat.buf = Buffer.from([0, 0, 0, 8]);
	expect(pat.readColorMode()).toBe("DUOTONE")
	pat.ofs = 0;

	pat.buf = Buffer.from([0, 0, 0, 9]);
	expect(pat.readColorMode()).toBe("LAB")
	pat.ofs = 0;

})

it("can read color table", () => {
	const pat:any = new PatParser();
	// longer than needed
	const chunk = new Array (
		0x38, 0x42, 0x50, 0x54, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x00, 0x00, 0x09, 0x00, 0x5f, 0x00, 0x69, 0x00, 0x6e, 0x00, 0x64, 0x00, 0x65, 0x00, 0x78, 0x00, 0x65, 0x00, 0x64, 0x00, 0x00, 0x24, 0x64, 0x39, 0x31, 0x31, 0x35, 0x62, 0x31, 0x61, 0x2d, 0x36, 0x37, 0x63, 0x63, 0x2d, 0x36, 0x33, 0x34, 0x33, 0x2d, 0x62, 0x39, 0x37, 0x63, 0x2d, 0x38, 0x65, 0x35, 0x31, 0x39, 0x63, 0x32, 0x31, 0x65, 0x38, 0x33, 0x66, 0xda, 0x10, 0xec, 0x10, 0x7d, 0xec, 0x10, 0xd5, 0xec, 0xca, 0xec, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xff, 0xff, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x9b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x1b
	);
	
	pat.buf = Buffer.from(chunk);
	pat.ofs = 81;
	const table = pat.readColorTable();
	expect(table.length).toEqual(256 * 3);

	expect(table.subarray(0, 3).toString("hex")).toBe("da10ec"); 
	expect(table.subarray(3, 6).toString("hex")).toBe("107dec");
	expect(table.subarray(6, 9).toString("hex")).toBe("10d5ec");
	expect(table.subarray(9, 12).toString("hex")).toBe("caec10");
	
	expect(table.subarray(12, 15).toString("hex")).toBe("000000");
	// the rest are zeros
	expect(table.subarray(12).toJSON()).toEqual(Buffer.alloc((256 * 3) - 12).fill(0).toJSON());
})


it("can parse file header", () => {
	let spy = jest.spyOn(PatParser.prototype as any, "decodePatternItem").mockImplementation(mockFn)
	const pat:any = new PatParser();
	// longer than needed
	var chunk = Buffer.from ([
		0x38, 0x42, 0x50, 0x54, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x04, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x72, 0x00, 0x67, 0x00, 0x62, 0x00, 0x00, 0x24, 0x64, 0x61, 0x31, 0x37, 0x62, 0x38, 0x34, 0x63, 0x2d, 0x38, 0x39, 0x39, 0x30, 0x2d, 0x64, 0x35, 0x34, 0x35, 0x2d, 0x39, 0x39, 0x64, 0x38, 0x2d, 0x34, 0x36, 0x32, 0x65, 0x37, 0x30, 0x64, 0x30, 0x39, 0x31, 0x36, 0x32, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	]);	

	expect(pat.decodeFile(chunk)).toEqual({
		version: 1,
		numberOfPatterns: 14,
		correctMagicBytes: true,
		patterns: Array(14).fill(undefined),
	} as IPatternFile)

	
	jest.restoreAllMocks();
	jest.clearAllMocks();
	jest.resetAllMocks();
})


it("can parse VMA", () => {
	let spy = jest.spyOn(PatParser.prototype as any, "decodeChannel").mockImplementation(mockFn)
	
	const pat:any = new PatParser();
	pat.tempLast = {
		patternItem: {
			colorMode: "RGB"
		}
	}
	var chunk = Buffer.from([
		0x38, 0x42, 0x50, 0x54, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x04, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x72, 0x00, 0x67, 0x00, 0x62, 0x00, 0x00, 0x24, 0x64, 0x61, 0x31, 0x37, 0x62, 0x38, 0x34, 0x63, 0x2d, 0x38, 0x39, 0x39, 0x30, 0x2d, 0x64, 0x35, 0x34, 0x35, 0x2d, 0x39, 0x39, 0x64, 0x38, 0x2d, 0x34, 0x36, 0x32, 0x65, 0x37, 0x30, 0x64, 0x30, 0x39, 0x31, 0x36, 0x32, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00,
		0x08, 0x00, 0xff, 0xff, 0xff, 0xc5, 0xff, 0xff, 0xff, 0x6d, 0xff, 0xff, 0x00, 0x00, 0xd1, 0x76, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0xd3, 0xd3, 0x3c, 0x3d, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x08, 0x00, 0x00, 0x4f, 0xe0, 0xff, 0x00, 0x00, 0xe1, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x33, 0xf7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x04, 0x00, 0x04, 0x00, 0x00, 0x00, 0x05, 0x00, 0x63, 0x00, 0x6d, 0x00, 0x79, 0x00, 0x6b, 0x00, 0x00, 0x24, 0x65, 0x39, 0x38, 0x31, 0x35, 0x36, 0x61, 0x61, 0x2d, 0x30, 0x37, 0x31, 0x61, 0x2d, 0x37, 0x39, 0x34, 0x30, 0x2d, 0x62, 0x33, 0x30, 0x37, 0x2d, 0x33,
		0x33, 0x35, 0x63, 0x62, 0x37, 0x39, 0x62, 0x39, 0x35, 0x34, 0x64, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x01, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	]);

	pat.buf = chunk;
	pat.ofs = 71;

	expect(pat.decodeVMA()).toEqual({
		bottom: 4,
		channels: [],
		left: 0,
		numberOfChannels: 4,
		right: 4,
		top: 0,
		version: 3
	} as IVMAL);

	jest.restoreAllMocks();
	jest.clearAllMocks();
	jest.resetAllMocks();
})

it("can parse pattern item", () => {
	let spy = jest.spyOn(PatParser.prototype as any, "decodeVMA").mockImplementation(mockFn)
	
	const pat:any = new PatParser();

	var chunk = Buffer.from([
		0x38, 0x42, 0x50, 0x54, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x04, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x72, 0x00, 0x67, 0x00, 0x62, 0x00, 0x00, 0x24, 0x64, 0x61, 0x31, 0x37, 0x62, 0x38, 0x34, 0x63, 0x2d, 0x38, 0x39, 0x39, 0x30, 0x2d, 0x64, 0x35, 0x34, 0x35, 0x2d, 0x39, 0x39, 0x64, 0x38, 0x2d, 0x34, 0x36, 0x32, 0x65, 0x37, 0x30, 0x64, 0x30, 0x39, 0x31, 0x36, 0x32, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00,
		0x08, 0x00, 0xff, 0xff, 0xff, 0xc5, 0xff, 0xff, 0xff, 0x6d, 0xff, 0xff, 0x00, 0x00, 0xd1, 0x76, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0xd3, 0xd3, 0x3c, 0x3d, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x08, 0x00, 0x00, 0x4f, 0xe0, 0xff, 0x00, 0x00, 0xe1, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x33, 0xf7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x04, 0x00, 0x04, 0x00, 0x00, 0x00, 0x05, 0x00, 0x63, 0x00, 0x6d, 0x00, 0x79, 0x00, 0x6b, 0x00, 0x00, 0x24, 0x65, 0x39, 0x38, 0x31, 0x35, 0x36, 0x61, 0x61, 0x2d, 0x30, 0x37, 0x31, 0x61, 0x2d, 0x37, 0x39, 0x34, 0x30, 0x2d, 0x62, 0x33, 0x30, 0x37, 0x2d, 0x33,
		0x33, 0x35, 0x63, 0x62, 0x37, 0x39, 0x62, 0x39, 0x35, 0x34, 0x64, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x01, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	]);

	pat.buf = chunk;
	pat.ofs = 10;

	expect(pat.decodePatternItem()).toEqual({
		colorMode: "RGB",
		hasAlphaChannel: true,
		height: 4,
		width: 4,
		memoryList: undefined,
		name: "rgb",
		uuid: "$da17b84c-8990-d545-99d8-462e70d09162",
		version: 1,
		table: undefined
	} as IPatternItem)
	

	jest.restoreAllMocks();
	jest.clearAllMocks();
	jest.resetAllMocks();
})

it("can decode channel", () => {
	let spy = jest.spyOn(PatParser.prototype as any, "readRawData").mockImplementation(mockFn);

	const pat:any = new PatParser();

	var buf = Buffer.from([
		0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x08, 0x00, 0x8a, 0x8c, 0x95, 0x80, 0x97, 0x8b, 0x96, 0x5e, 0xdd, 0xdc, 0x5d, 0x5e, 0xf0, 0xe4, 0xe0, 0xe6, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x08, 0x00, 0xd1, 0xd2, 0xdb, 0xd3, 0xc4, 0xd0, 0xdb, 0xc8, 0x84, 0x85, 0xb1, 0xb0, 0x5e, 0x40, 0x32, 0x4b, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x08, 
		0x00, 0xc6, 0xa2, 0x53, 0x33, 0xc7, 0xc6, 0x52, 0x1c, 0xd6, 0xd6, 0x1c, 0x1c, 0xda, 0xd3, 0xc9, 0x75, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x04, 0x00, 0x00, 0x00, 0x05, 0x00, 0x67, 0x00, 
		0x72, 0x00, 0x61, 0x00, 0x79, 0x00, 0x00, 0x24, 0x35, 0x30, 0x63, 0x65, 0x37, 0x66, 0x62, 0x63, 0x2d, 0x63, 0x35, 0x36, 0x35, 0x2d, 0x30, 0x39, 0x34, 0x39, 0x2d, 0x61, 0x33, 0x64, 0x63, 0x2d
	]);

	pat.buf = buf;
	pat.ofs = 4;

	expect(pat.decodeChannel()).toEqual({
		exists: true,
		top:0,
		left: 0,
		bottom: 4,
		right: 4,
		pixelDepth: 8,
		compressionMode: "NONE",
		rawData: undefined
	} as IChannel)


	jest.restoreAllMocks();
	jest.clearAllMocks();
	jest.resetAllMocks();
})

it("can read raw data", () => {
	const pat:any = new PatParser();

	pat.buf = Buffer.from([0xff, 0xff, 0xff, 0xc5, 0xff, 0xff, 0xff, 0x6d, 0xff, 0xff, 0x00, 0x00, 0xd1, 0x76, 0x00, 0x00]);

	expect(pat.readRawData(39, "NONE").toJSON().data).toEqual([255, 255, 255, 197, 255, 255, 255, 109, 255, 255, 0, 0, 209, 118, 0, 0]);
})

it("can decode compressed bitmap", () => {
	const pat: any = new PatParser();
	
	// Created with HHD Software Hex Editor Neo
	// http://www.hhdsoftware.com
	//
	// File: A:\PS-projects\pat-parser\test\patterns\SubtlePatterns.pat
	//
	// Block 1:
	// Offset: 0x0040a157 (4 235 607)
	// Size: 0x0000009c (156) bytes

	var compressed = [
		0x00, 0x08, 0x00, 0x09, 0x00, 0x0a, 0x00, 0x0a, 0x00, 0x0a, 0x00, 0x09, 0x00, 0x08, // bytes per row?
		0x00, 0x08, 0x00, 0x09, 0x00, 0x0a, 0x00, 0x0a, 0x00, 0x0a, 0x00, 0x09, 0x00, 0x08, // bytes per row?

		0xfb, 0x00, 0x00, 0x1b, 0xfb, 0x00, 0x00, 0x22, //8
		0xfc, 0x00, 0x00, 0x19, 0xfb, 0x00, 0x01, 0x20, 0x00, // 9
		0xfd, 0x00, 0x00, 0x17, 0xfb, 0x00, 0x02, 0x1d, 0x00, 0x00, //10
		0xfe, 0x00, 0x00, 0x14, 0xfb, 0x00, 0x00, 0x1b, 0xfe, 0x00,
		0xff, 0x00, 0x00, 0x14, 0xfb, 0x00, 0x00, 0x19, 0xfd, 0x00,
		0x01, 0x00, 0x17, 0xfb, 0x00, 0x00, 0x17, 0xfc, 0x00, 
		0x00, 0x19, 0xfb, 0x00, 0x00, 0x14, 0xfb, 0x00,
		0xfb, 0x00, 0x00, 0x14, 0xfb, 0x00, 0x00, 0x1b,
		0xfc, 0x00, 0x00, 0x17, 0xfb, 0x00, 0x01, 0x1d, 0x00,
		0xfd, 0x00, 0x00, 0x19, 0xfb, 0x00, 0x02, 0x20, 0x00, 0x00,
		0xfe, 0x00, 0x00, 0x1b, 0xfb, 0x00, 0x00, 0x22, 0xfe, 0x00,
		0xff, 0x00, 0x00, 0x1d, 0xfb, 0x00, 0x00, 0x22, 0xfd, 0x00,
		0x01, 0x00, 0x20, 0xfb, 0x00, 0x00, 0x20, 0xfc, 0x00,
		0x00, 0x22, 0xfb, 0x00, 0x00, 0x1d, 0xfb, 0x00
	];
	// End of Block 1

	pat.buf = Buffer.from(compressed);

	pat.tempLast.channel = {
		pixelDepth: 8,
		bottom: 14,
		right: 14
	};

	pat.tempLast.vma = {
		numberOfChannels: 3
	}

	const expectBuf = Buffer.from([
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1b, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1b,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x1d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	])

	
	const dec = pat.decodePackBits(pat.buf.subarray(28, 196), 196);

	expect(expectBuf.toJSON().data).toEqual(dec.toJSON().data);
	expect(pat.readRawData(179, "PackBits").toJSON()).toEqual(expectBuf.toJSON());
})